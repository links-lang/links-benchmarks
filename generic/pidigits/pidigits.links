module JSBigInt{
  alien javascript "/js/BigInt.js" {
      # String represents a number
      div: (String, String) -> String;
      add: (String, String) -> String;
      mult: (String, String) -> String;
  }
}

typename BigNum = [|BigNumStr:String|];



module BigNum {
  # Construct BigNum with an Int
  sig fromInt: (Int) -> BigNum
  fun fromInt(n) { BigNumStr(intToString(n)) }

  # Get String representation of BigNum
  sig toString: (BigNum) -> String
  fun toString(bn) {
    var BigNumStr(n) = bn;
    (n ^^ "")
  }
}

typename LFT = (BigNum, BigNum, BigNum, BigNum);

module LFT {
  fun fromInts(a, b, c, d) {
    (BigNum.fromInt(a), BigNum.fromInt(b), BigNum.fromInt(c), BigNum.fromInt(d)) : LFT
  }

  # TODO: Unused?
  # Get String representation of LFT
  # sig toString : (LFT) -> String
  # fun toString (m) {
  #   var (BigNumStr(a), BigNumStr(b), BigNumStr(c), BigNumStr(d)) = m;
  #   ("(" ^^ a ^^ "," ^^ b ^^ "," ^^ c ^^ "," ^^ d ^^ ")")
  # }
}

# Some operators on BigNum
op x <+> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.add(x, y))
}

op x <*> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.mult(x, y))
}

op x </> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.div(x, y))
}

# Set precedence
infixl 3 <*>;
infixl 3 </>;
infixl 2 <+>;

var unit = LFT.fromInts(1,0,0,1);

fun comp(m1: LFT, m2: LFT) {
  var (q, r, s, t) = m1;
  var (u, v, w, x) = m2;
  (q<*>u <+> r<*>w, q<*>v <+> r<*>x,
   s<*>u <+> t<*>w, s<*>v <+> t<*>x)
}

fun floorExtr(m, x) {
  var (q, r, s, t) = m;
  var numerator = (q <*> x <+> r);
  var denominator = (s <*> x <+> t);
  (numerator </> denominator) : BigNum
  # Log - division: println("Dividing " ^^ numerator ^^ "by" ^^ denominator);
}

fun next(z: LFT) {
  floorExtr(z, BigNum.fromInt(3))
}

fun prod(z: LFT, n: BigNum) {
  var m = (BigNum.fromInt(10), BigNum.fromInt(-10)<*>n, BigNum.fromInt(0), BigNum.fromInt(1));
  comp(m, z): LFT
}

fun safe(z: LFT, n: BigNum) {
  n == floorExtr(z, BigNum.fromInt(4)): Bool
}


var cons = comp;
var init = unit;

sig stream: (LFT, [LFT]) ~> [BigNum]
fun stream(z, inputs) {
  switch (inputs) {
    case []      -> []
    case (x::xs) -> {
      var y = next(z); 
      if (safe(z, y))
        y :: stream(prod(z, y), x::xs)
      else
        stream(comp(z, x), xs)
    }
  }
}

var inputMatrixCount = 100;

# Some functions for printing 
fun join(sep, xs) { fold_left1(fun(x,y) { x ^^ sep ^^ y }, xs) }
# Note: Empty string required to avoid addition of integer at client side
fun concat(xs) { join("", xs) }

sig printPidigits: ([BigNum]) ~> ()
fun printPidigits(digits) {
  fun printPidigits'(digits, charCount, lineCount) {
    switch (digits) {
      case [] -> {
        var fillSpaceCount = 10 - charCount;
        println(
          concat(replicate(fillSpaceCount, " "))  ^^ "\t:"  # Whitespace for formatting
          ^^ intToString(lineCount * 10 + charCount)        # Digit count
        )
      }
      case (x :: xs) -> {
        if (charCount == 10) {
          println(BigNum.toString(x) ^^ "\t:" ^^ intToString((lineCount + 1)*10));
          printPidigits'(xs, 0, lineCount + 1)
        } else {
          print(BigNum.toString(x));
          printPidigits'(xs, charCount + 1, lineCount + 1)
        }
      }
    }
  }
  printPidigits'(digits, 0, 0)
}

# Client stuff
fun mainPage(_) {
  var _ = spawnClient {
    var lfts = {
      for (k <- [1..inputMatrixCount]) {
        var a = BigNum.fromInt(k);
        var b = BigNum.fromInt(4)<*>BigNum.fromInt(k)<+>BigNum.fromInt(2);
        var c = BigNum.fromInt(0);
        var d = BigNum.fromInt(2)<*>BigNum.fromInt(k)<+>BigNum.fromInt(1);
        [(a,b,c,d)]
      } 
    };

    var resultBigNums= stream(unit, lfts) : [BigNum];
    printPidigits(resultBigNums)
  };

  page
    <html>
      <body>
        <h1>Open console for the output</h1>
      </body>
    </html>
}

fun main() {
  addRoute("/", mainPage);
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  servePages()
}

main()