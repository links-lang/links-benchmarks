module JSBigInt{
  alien javascript "/js/BigInt.js" {
      # String represents a number
      div: (String, String) -> String;
      add: (String, String) -> String;
      mult: (String, String) -> String;
  }
}

typename BigNum = [|BigNumStr:String|];

fun bigNum(n) {
  var numStr = intToString(n);
  BigNumStr(numStr)
}

fun bigNumToString(bn) {
  var BigNumStr(n) = bn;
  n
}

typename LFT = (BigNum, BigNum, BigNum, BigNum);

fun lftFromTuple (a, b, c, d) {
  (bigNum(a), bigNum(b), bigNum(c), bigNum(d)) : LFT
}

sig lftToString : (LFT) -> String
fun lftToString(m) {
  var (BigNumStr(a), BigNumStr(b), BigNumStr(c), BigNumStr(d)) = m;
  ("(" ^^ a ^^ "," ^^ b ^^ "," ^^ c ^^ "," ^^ d ^^ ")")
}

op x <+> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.add(x, y))
}

op x <*> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.mult(x, y))
}

op x </> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.div(x, y))
}

infixl 3 <*>;
infixl 3 </>;
infixl 2 <+>;

var unit = lftFromTuple(1,0,0,1);


fun join(sep, xs) { fold_left1(fun(x,y) { x ^^ sep ^^ y }, xs) }

# Note: Empty string required to avoid addition of integer at client side
fun concat(xs) { join("", xs) }

fun comp(m1: LFT, m2: LFT) {
  var (q, r, s, t) = m1;
  var (u, v, w, x) = m2;
  (q<*>u <+> r<*>w, q<*>v <+> r<*>x,
   s<*>u <+> t<*>w, s<*>v <+> t<*>x)
}

fun floorExtr(m, x) {
  var (q, r, s, t) = m;
  var numerator = (q <*> x <+> r);
  var denominator = (s <*> x <+> t);
  (numerator </> denominator) : BigNum
  # Log - division: println("Dividing " ^^ numerator ^^ "by" ^^ denominator);
}

fun next(z: LFT) {
  floorExtr(z, bigNum(3))
}

fun prod(z: LFT, n: BigNum) {
  var m = (bigNum(10), bigNum(-10)<*>n, bigNum(0), bigNum(1));
  comp(m, z): LFT
}

fun safe(z: LFT, n: BigNum) {
  n == floorExtr(z, bigNum(4)): Bool
}


var cons = comp;
var init = unit;

# sig stream: (LFT, [LFT]) -> [BigNum]
fun stream(z, inputs) {
  switch (inputs) {
    case []      -> []
    case (x::xs) -> {
      var y = next(z); 
      if (safe(z, y))
        y :: stream(prod(z, y), x::xs)
      else
        stream(comp(z, x), xs)
    }
  }
}

var inputMatrixCount = 100;

# Client stuff
fun mainPage(_) {
  var _ = spawnClient {
    var lfts = {
      for (k <- [1..inputMatrixCount]) {
        var a = bigNum(k);
        var b = bigNum(4)<*>bigNum(k)<+>bigNum(2);
        var c = bigNum(0);
        var d = bigNum(2)<*>bigNum(k)<+>bigNum(1);
        [(a,b,c,d)]
      } 
    };


    var resultBigNums= stream(unit, lfts) : [BigNum];
    var resultOutput = concat(map(bigNumToString, resultBigNums));

    println(resultOutput)

  };

  page
    <html><body><h1>Hi!</h1></body></html>
}

fun main() {
  addRoute("/", mainPage);
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  servePages()
}

main()