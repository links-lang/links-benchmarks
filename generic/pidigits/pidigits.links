module JSBigInt{
  alien javascript "/js/BigInt.js" {
      # String represents a number here
      div: (String, String) -> String;
      add: (String, String) -> String;
      mult: (String, String) -> String;
  }
}

typename BigNum = [|BigNumStr:String|];

module BigNum {
  # Construct BigNum with an Int
  sig fromInt: (Int) -> BigNum
  fun fromInt(n) { BigNumStr(intToString(n)) }

  # Get String representation of BigNum
  sig toString: (BigNum) -> String
  fun toString(bn) {
    var BigNumStr(n) = bn;
    (n ^^ "")
  }
}

typename LFT = (BigNum, BigNum, BigNum, BigNum);

module LFT {
  fun fromInts(a, b, c, d) {
    (BigNum.fromInt(a), BigNum.fromInt(b), BigNum.fromInt(c), BigNum.fromInt(d)) : LFT
  }
}

# Some operators on BigNum
op x <+> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.add(x, y))
}

op x <*> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.mult(x, y))
}

op x </> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.div(x, y))
}

# Set operator precedence
infixl 3 <*>;
infixl 3 </>;
infixl 2 <+>;

var unit = LFT.fromInts(1,0,0,1);

fun comp(m1: LFT, m2: LFT) {
  var (q, r, s, t) = m1;
  var (u, v, w, x) = m2;
  (q<*>u <+> r<*>w, q<*>v <+> r<*>x,
   s<*>u <+> t<*>w, s<*>v <+> t<*>x)
}

fun floorExtr(m, x) {
  var (q, r, s, t) = m;
  var numerator = (q <*> x <+> r);
  var denominator = (s <*> x <+> t);
  (numerator </> denominator) : BigNum
}

fun next(z: LFT) {
  floorExtr(z, BigNum.fromInt(3))
}

fun prod(z: LFT, n: BigNum) {
  var m = (BigNum.fromInt(10), BigNum.fromInt(-10)<*>n, BigNum.fromInt(0), BigNum.fromInt(1));
  comp(m, z): LFT
}

fun safe(z: LFT, n: BigNum) {
  n == floorExtr(z, BigNum.fromInt(4)): Bool
}

var cons = comp;
var init = unit;

sig stream: (LFT, Int, Int, Int) ~> [BigNum]
fun stream(z, lftIndex, digitCount, n) {
  if (digitCount == n)
    []
  else {
    var x = { 
      var a = BigNum.fromInt(lftIndex);
      var b = BigNum.fromInt(4)<*>BigNum.fromInt(lftIndex)<+>BigNum.fromInt(2);
      var c = BigNum.fromInt(0);
      var d = BigNum.fromInt(2)<*>BigNum.fromInt(lftIndex)<+>BigNum.fromInt(1);
      (a,b,c,d) : LFT
    };
    var y = next(z); 
    if (safe(z, y))
      y :: stream(prod(z, y), lftIndex, digitCount + 1, n)
    else
      stream(comp(z, x), lftIndex + 1, digitCount, n)
  }
}

# Some functions for printing 
fun join(sep, xs) { fold_left1(fun(x,y) { "" ^^ x ^^ sep ^^ y }, xs) }
# Note: Empty string required to avoid addition of integer in JS 
fun concat(xs) { join("", xs) }

sig printPidigits: ([BigNum]) ~> ()
fun printPidigits(digits) {
  fun printPidigits'(digits, lineCount) {
    switch (digits) {
      case [] -> ()
      case xs -> {
        var fstTenNums = take(10, digits);
        var tail = drop(10, digits);

        var charCount = length(fstTenNums);
        var fillSpaceCount = 10 - charCount;
        println(
          concat(map(BigNum.toString, fstTenNums))          # Digits  
          ^^ implode(replicate(fillSpaceCount, ' '))        # Whitespace
          ^^ "\t:"      
          ^^ intToString(lineCount * 10 + charCount)        # Digit count
        );

        printPidigits'(tail, lineCount + 1)
      }
    }
  }
  printPidigits'(digits, 0)
}

fun mainPage(_) {
  # Input: Number of digits of pi requested
  var n = 99;

  var _ = spawnClient {
    var resultBigNums= stream(unit, 1, 0, n) : [BigNum];
    printPidigits(resultBigNums)
  };

  page
    <html>
      <body>
        <h1>Open console for the output</h1>
      </body>
    </html>
}

fun main() {
  addRoute("/", mainPage);
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  servePages()
}

main()