module JSBigInt{
  alien javascript "/js/BigInt.js" {
      # String represents a number
      div: (String, String) -> String;
      add: (String, String) -> String;
      mult: (String, String) -> String;
  }
}

typename BigNum = [|BigNumStr:String|];



module BigNum {
# Construct BigNum with an Int
  sig fromInt: (Int) -> BigNum
  fun fromInt(n) { BigNumStr(intToString(n)) }

  fun toString(bn) {
    var BigNumStr(n) = bn;
    n
  }
}



typename LFT = (BigNum, BigNum, BigNum, BigNum);

module LFT {
  fun fromInts(a, b, c, d) {
    (BigNum.fromInt(a), BigNum.fromInt(b), BigNum.fromInt(c), BigNum.fromInt(d)) : LFT
  }

  # TODO: Unused?
  # sig toString : (LFT) -> String
  # fun toString (m) {
  #   var (BigNumStr(a), BigNumStr(b), BigNumStr(c), BigNumStr(d)) = m;
  #   ("(" ^^ a ^^ "," ^^ b ^^ "," ^^ c ^^ "," ^^ d ^^ ")")
  # }
}

op x <+> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.add(x, y))
}

op x <*> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.mult(x, y))
}

op x </> y {
  var BigNumStr(x) = x;
  var BigNumStr(y) = y;
  BigNumStr(JSBigInt.div(x, y))
}

infixl 3 <*>;
infixl 3 </>;
infixl 2 <+>;

var unit = LFT.fromInts(1,0,0,1);


fun join(sep, xs) { fold_left1(fun(x,y) { x ^^ sep ^^ y }, xs) }

# Note: Empty string required to avoid addition of integer at client side
fun concat(xs) { join("", xs) }

fun comp(m1: LFT, m2: LFT) {
  var (q, r, s, t) = m1;
  var (u, v, w, x) = m2;
  (q<*>u <+> r<*>w, q<*>v <+> r<*>x,
   s<*>u <+> t<*>w, s<*>v <+> t<*>x)
}

fun floorExtr(m, x) {
  var (q, r, s, t) = m;
  var numerator = (q <*> x <+> r);
  var denominator = (s <*> x <+> t);
  (numerator </> denominator) : BigNum
  # Log - division: println("Dividing " ^^ numerator ^^ "by" ^^ denominator);
}

fun next(z: LFT) {
  floorExtr(z, BigNum.fromInt(3))
}

fun prod(z: LFT, n: BigNum) {
  var m = (BigNum.fromInt(10), BigNum.fromInt(-10)<*>n, BigNum.fromInt(0), BigNum.fromInt(1));
  comp(m, z): LFT
}

fun safe(z: LFT, n: BigNum) {
  n == floorExtr(z, BigNum.fromInt(4)): Bool
}


var cons = comp;
var init = unit;

# sig stream: (LFT, [LFT]) -> [BigNum]
fun stream(z, inputs) {
  switch (inputs) {
    case []      -> []
    case (x::xs) -> {
      var y = next(z); 
      if (safe(z, y))
        y :: stream(prod(z, y), x::xs)
      else
        stream(comp(z, x), xs)
    }
  }
}

var inputMatrixCount = 100;

# Client stuff
fun mainPage(_) {
  var _ = spawnClient {
    var lfts = {
      for (k <- [1..inputMatrixCount]) {
        var a = BigNum.fromInt(k);
        var b = BigNum.fromInt(4)<*>BigNum.fromInt(k)<+>BigNum.fromInt(2);
        var c = BigNum.fromInt(0);
        var d = BigNum.fromInt(2)<*>BigNum.fromInt(k)<+>BigNum.fromInt(1);
        [(a,b,c,d)]
      } 
    };


    var resultBigNums= stream(unit, lfts) : [BigNum];
    var resultOutput = concat(map(BigNum.toString, resultBigNums));

    println(resultOutput)

  };

  page
    <html><body><h1>Hi!</h1></body></html>
}

fun main() {
  addRoute("/", mainPage);
  addStaticRoute("/js", "js", [("js", "text/javascript")]);
  servePages()
}

main()