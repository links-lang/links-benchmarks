
# representation of 2x2 matrix transformation
typename LFT = (Int, Int, Int, Int);

# Identity matrix with respect to `comp` function (i.e. matrix multiplication)
var unit = (1, 0, 0 ,1);

# Convert LFT into String representation
sig toStr : (LFT) -> String
fun toStr(m: LFT) {
  var (a, b, c, d) = m;
  ("(" ^^ intToString(a) ^^ "," ^^ intToString(b) ^^ ","
    ^^ intToString (c) ^^ "," ^^ intToString(b) ^^ ")"): String
}

# Matrix multiplication on LFT
sig comp : (LFT, LFT) -> LFT
fun comp(m1: LFT, m2: LFT) {
  var (q, r, s, t) = m1;
  var (u, v, w, x) = m2;
  (q*u+r*w, q*v+r*x,
   s*u+t*w, s*v+t*x) : LFT
}

sig floorExtr : (LFT, Int) -> Int
fun floorExtr(m: LFT, x: Int) {
  var (q, r, s, t) = m;
  var num = (q * x + r);
  var den = (s * x + t);
  (num / den) : Int
}


sig next : (LFT) -> Int
fun next(z: LFT) {
  floorExtr(z, 3)
}

sig safe : (LFT, Int) -> Bool
fun safe(z: LFT, n: Int) {
  n == floorExtr(z, 4): Bool
}

sig prod : (LFT, Int) -> LFT
fun prod(z: LFT, n: Int) {
  var m = (10, -10*n, 0, 1);
  comp(m, z): LFT
}

sig cons : (LFT, LFT) -> LFT
var cons = comp;

sig init : LFT
var init = unit;

# Streaming algorithm implementation
sig stream : (LFT, [LFT]) ~> [Int]
fun stream(z: LFT, inputs: [LFT]) {
  switch (inputs) {
    case []      -> []
    case (x::xs) -> {
      var y = next(z); 
      if (safe(z, y))
        y :: stream(prod(z, y), x::xs)
      else
        stream(cons(z, x), xs)
    }
  }
}

fun main() {
  # Input size
  var n = 5;

  var lfts = {
    for (k <- [1..n*5])
      [(k, 4*k+2, 0, 2*k+1)] : [LFT]
  };
  
  stream(unit, lfts)
}

main()